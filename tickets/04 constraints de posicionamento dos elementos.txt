ONDE:
ZineMob

SOLICITAÇÃO:

- Criação de constraints de posicionamento / tamanho, para que os elementos sejam ajustados automaticamente aos pais ou filhos.

- Tipos de constraints:
	- fit to children: atualiza a sua posição e tamanho para abranger o espaço dos filhos.
		- o elemento tem a sua posição e tamanho atualizados quando um filho direto tem a sua posição ou tamanho alterados
		- quando a posição deste elemento é alterada pela constraint, os filhos devem permanecer na mesma posição global
		- não é possível atualizar mais o tamanho e posição deste elemento se esta constraint estiver aplicada, pois não surtirá efeito
	- stretch to parent: atualiza a sua posição e/ou tamanho para ter seu posicionamento e tamanho igual ao pai
		- o elemento tem a sua posição e tamanho atualizados quando o seu pai direto tem a sua posição ou tamanho alterados
		- pode não ser possível atualizar mais o tamanho e posição deste elemento se esta constraint estiver aplicada, pois não surtirá efeito
		- por padrão, o elemento é esticado de forma que ocupe todo o espaço do pai, porém podem ser configurados quais lados são esticados:
		acima, abaixo, esquerda e direita.
	- fit position to parent: semelhante a fit to parent, mas atualiza apenas a posição do elemento, não o seu tamanho
		- o elemento tem a sua posição atualizada quando o seu pai direto tem a sua posição alterada
		- pode não ser possível atualizar mais a posição deste elemento se esta constraint estiver aplicada, pois não surtirá efeito
		- ao usar esta constraint, define-se qual parte do elemento ficará alinhado com qual parte do pai, tanto em X quanto em Y. Exemplo:
		aresta esquerda do objeto é alinhada à aresta direita do pai, e aresta superior é alinhada ao centro do pai. As opções são: aresta
		esquerda, direita, superior e inferior; centro horizontal, centro vertical e ponto do pivô do objeto.

- As constraints podem ser adicionadas ao elemento para gerenciá-lo para sempre (ou até serem removidos) ou podem ser aplicados apenas uma vez, para aplicar o seu efeito no momento da chamada.


- a aplicação das constraints também consideram dois novos tipos de atributos dos drawable elements:
	- padding: o espaço entre o pai e o seu conteúdo (os seus filhos), ou seja, esta propriedade é definida no elemento pai
	- margin: é o contrário do padding: é o espaço entre o filho e o pai, ou seja, esta propriedade é definida no elemento filho
		- ou seja, quando é calculado o espaço, é feita a soma do padding do pai com a margin do filho
		
- métodos no DrawableElement para definir o padding e a margin
	- setPadding(int), setPadding(int left, int top, int right, int bottom), setMargin(int), setMargin(int, int, int, int)
	- getPaddingTop, getPaddingRight..., getMarginTop, getMarginRight...

- métodos das constraints no DrawableElement:
	- addConstraint(DrawableElementConstraint) -> aplica a constraint no elemento, que continua a ser gerenciado pela constraint. A ordem das
	constraints adicionadas pode obviamente surtir efeito.
	- getConstraints() -> retorna as constraints adicionadas em addConstraint
	- removeConstraint(DrawableElementConstraint) -> remove a constraint do elemento
	- applyConstraint(DrawableElementConstraint) -> apenas aplica o efeito da constraint no momento da chamada deste método, mas o elemento não continua sendo gerenciado pela constraint

- classe DrawableElementConstraint
	- método applyConstraint(DrawableElement) -> aplica a constraint no elemento
	
- momentos em que o método applyConstraint da constraint é aplicado:
	- quando o elemento tem a sua posição alterada
	- quando o elemento tem o seu tamanho alterado
		- em ambos os casos, também chama pelo applyConstraint para o elemento pai
		- quando uma constraint está sendo aplicada, ela poderá alterar a posição e tamanho do elemento; nestes casos, a constraint não pode ser reaplicada nas chamadas para alteração de posição ou tamanho.
			- contudo, caso a constraint altere outro elemento (exemplo: filho, ou pai), a constraint deve ser aplicada.
			- a regra básica é que, quando uma constraint é aplicada, várias outras podem ser aplicadas por consequência, porém isso acontecerá sempre apenas uma vez, para evitar recursividade.

- ao invés de Constraint ou DrawableElementConstraint, considerar o uso de um dos seguintes nomes:
	- EdgesBinder -> método bindEdges
	- EdgesFixer -> método fixEdges
	- Holder -> método hold
	- Fixer -> método fix
	- AreaFixer -> método fixArea
	- AreaHandler -> método handleArea
	- AreaConstraint -> applyConstraint

ANEXOS:
04 attachment.svg

DESENVOLVIMENTO:

- em fit to children, é possível sim alterar a posição do elemento (ao contrário do que diz a especificação), pois no caso todos os filhos se
moverão junto com o elemento. O tamanho, porém, continua sendo impossível de alterar.


